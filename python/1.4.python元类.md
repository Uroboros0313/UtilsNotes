# 元类
## 什么是类   

- 类在python中是以class开头的，定义怎么生成类实例的一段代码段。
- 类也是对象,在python的面向对象程序设计(Object Oriented Programming,OOP)的模式中
    
    使用关键字`class`，Python就会执行它并在内存中创建一个对象。这个对象（类）本身能够创建对象（实例），这就是为什么它是一个类。

## 动态创建类

利用`type`动态创建类   
```
type(name, bases, attrs)

name: 类名
bases: 父类的元组（用于继承，可以为空）
attrs: 包含attrs名称和值的字典,包括实例方法
```
当type只有一个入参时是python自省中判断数据类型的函数，三个入参时可以动态创建类。

```python
def __init__(self, ins_id):
    self.ins_id = ins_id

@classmethod
def create_ins(cls):
    cls.ins_id += 1
    return cls(cls.ins_id)

BaseCls = type("BaseCls",(),{"name":"base_cls",
                   "create_date":"2022-08-23",
                   "ins_id":0,
                   "__init__":__init__,
                   "create_ins":create_ins})

base_ins_0 = BaseCls(0)
print(base_ins_0.ins_id) # 0
print(BaseCls.ins_id) # 0

base_ins_1 = BaseCls.create_ins()
print(base_ins_1.ins_id) # 1
print(BaseCls.ins_id) # 1

```
等价于
```python
class BaseCls:
    name = "base_cls"
    create_date = "2022-08-23"
    ins_id = 0

    def __init__(self, ins_id):
        self.ins_id = 0
    
    @classmethod
    def create_ins(cls):
        cls.ins_id += 1
        return cls(cls.ins_id)
```

python使用class构建类时所做的操作，通过metaclass实现。

## 什么是metaclass

元类是创建类的类

```python
BaseCls = MetaClass()
base_instance = BaseCls()
```

其中`MetaClass()`就是元类，而利用`type("BaseCls",(),{})`方法创建的类和上述一样，`type`就是元类。python中的一切都是对象，都基于一个类创建。

```python
class BaseCls:
    def BaseOp(self):
        pass

print(BaseCls.__class__)
base_case = BaseCls()
print(base_case.__class__)
print(base_case.__class__.__class__)

# <class 'type'>
# <class '__main__.BaseCls'>
# <class 'type'>
```
## 创建元类

`type`是Python使用的内置元类，当然也可以创建自己的元类。

### python3创建元类
```python
class BaseCls(metaclass = obj):
```

### python2创建元类

```python
class BaseCls(object):
    __metaclass__ = obj
```
### 自定义元类  

python的metaclass实际上会自动获取关于类的三个参数(和`type`相同的`name,parents,attrs`)

```python
def upper_attrs(cls_name, cls_parents, cls_attrs):
    upper_cls_attrs = {
        attr if attr.startswith("_") else attr.upper() : v
        for attr, v in cls_attrs.items()
    }
    print(upper_cls_attrs)

    return type(cls_name, cls_parents, upper_cls_attrs)

# python3 style
class BaseCls(metaclass = upper_attrs):
    _private = "private"
    public = "public"

print(hasattr(BaseCls, "public"))
print(hasattr(BaseCls, "PUBLIC"))
print(hasattr(BaseCls, "_private"))

'''
{'__module__': '__main__', '__qualname__': 'BaseCls', 
'_private': 'private', 'PUBLIC': 'public'}
'''

# False
# True
# True
```

### python类创建元类

metaclass复杂在metaclass常用来处理类似于python自省，python操纵继承，python处理`__dict__`的变量用。

metaclass本质上的作用非常清晰:

1. 拦截类
2. 修改类
3. 返回修改后的类


```python
class UpperAttrs(type):
    def __new__(cls, clsname, bases, attrs):
        upper_attrs = {
            attr if attr.startswith("_") else attr.upper(): v 
            for attr, v in attrs.items()
        }
        print(f"metaclass {cls.__name__}.__new__ init")

        #return type(clsname, bases, upper_attrs) # this method do not override(覆写) `__new__`
        #return type.__new__(cls, clsname, bases, upper_attrs)
        # using `super()` is cleaner way
        return super().__new__(cls, clsname, bases, upper_attrs)

class BaseCls(metaclass = UpperAttrs):
    _private = "private"
    public = "public"

print(hasattr(BaseCls, "public"))
print(hasattr(BaseCls, "PUBLIC"))
print(hasattr(BaseCls, "_private"))

# metaclass UpperAttrs.__new__ init
# False
# True
# True
```

## 为什么要使用元类类而不是函数



1. 意图明确。当你阅读时UpperAttrMetaclass(type)，你知道接下来会发生什么
2. 可以使用OOP。元类可以继承元类，覆盖父方法。元类甚至可以使用元类。
3. 如果指定了元类，则子类将是其元类的实例，但不是元类函数的实例。
4. 更好地构建代码。
5. 可以挂上`__new__`,`__init__`和`__call__`。这样可以做不同的事情，即使通常可以在`__new__`全部完成。
6. 
# reference
[1] [stackoverflow:What are metaclasses in Python?](http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python)